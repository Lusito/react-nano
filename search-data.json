[{"url":"https://lusito.github.io/react-nano/","content":"@react-nano\nTiny, powerful and type-safe React libraries. All released under a liberal license: zlib/libpng\nLibraries\n\n@react-nano/redux\nLightweight alternative to react-redux.\n@react-nano/redux-dynamic-modules\nMaking redux-dynamic-modules more lightweight by using @react-nano/redux instead of react-redux.\n@react-nano/router\nLightweight alternative to react-router.\n@react-nano/tsrux\nLightweight alternative to redux-actions, deox, etc.\n@react-nano/use-event-source\nHook for using Server-Sent-Events.\n@react-nano/use-fetch\nHook for using fetch() to GET, POST, etc. requests.\n@react-nano/use-graphql\nHook for using GraphQL queries and mutations.\n\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"@react-nano"},{"url":"https://lusito.github.io/react-nano/redux/","content":"@react-nano/redux\n\n\n\n\n\nA simple, lightweight react-redux alternative, written in TypeScript.\nWhy Use @react-nano/redux?\n\nVery lightweight (see the badges above for the latest size).\nAll hooks are compatible to react-redux\nOnly has two peer dependencies:\n\nReact 17.0.0 or higher\nRedux 4.0.0 or higher\n\n\nUsing hooks to access redux in react is soo much cleaner than using react-redux's connect higher order component.\nLiberal license: zlib/libpng\n\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"redux","projectIndex":{"title":"redux","url":"https://lusito.github.io/react-nano/redux/"}},{"url":"https://lusito.github.io/react-nano/redux/hooks.html","content":"Hooks\nuseDispatch\nUse the hook to dispatch actions like this:\nimport { useDispatch } from \"@react-nano/redux\";\nexport const MyComponent = () => {\n  const dispatch = useDispatch();\n\n  return <button onClick={() => dispatch(subscribeAction())}>Subscribe</button>;\n};\n\nuseSelector\nUse the hook to get a state property:\nimport { useSelector } from \"@react-nano/redux\";\n\nconst selectTitle = (state: State) => state.title;\n\nexport const MyComponent = () => {\n  const title = useSelector(selectTitle);\n\n  return <h2>{title}</h2>;\n};\n\nCustom Comparison Function\nuseSelector will detect changes in the value returned by the selector function by comparing the old value and the new value by reference. Only if they differ, the component will be re-rendered.\nIf you want more control, you can pass in a comparison function:\nimport { useSelector } from \"@react-nano/redux\";\n\nconst selectUsers = (state: State) => state.users;\n\nconst sameMembersInArray = (a: User[], b: User[]) => {\n  if (a.length !== b.length) return false;\n  return a.every((value, index) => value === b[index]);\n};\n\nexport const MyComponent = () => {\n  const users = useSelector(selectUsers, sameMembersInArray);\n\n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n};\n\nuseStore\nIn some rare occasions, you might want to access the store object itself:\nimport { useStore } from \"@react-nano/redux\";\nexport const MyComponent = () => {\n  const store = useStore();\n  // ...\n};\n\n","title":"Hooks","projectIndex":{"title":"redux","url":"https://lusito.github.io/react-nano/redux/"}},{"url":"https://lusito.github.io/react-nano/redux/migrating-from-react-redux.html","content":"Migrating From react-redux\nThis library defines a different provider, which works the same way, but it does not provide the redux store to react-redux.\nSo using the original hooks and connect functions from react-redux won't work.\nThat is easily fixed though: If you want to gradually move code from react-redux to @react-nano/redux, simply add one Provider for each library:\nimport { Provider } from \"@react-nano/redux\";\nimport { Provider as LegacyProvider } from \"react-redux\";\nexport const App = () => (\n  <Provider store={store}>\n    <LegacyProvider store={store}>...your app content...</LegacyProvider>\n  </Provider>\n);\n\nNow all you need to do is migrate your components to use hooks instead of connect(). If you are already using hooks, then it's just a matter of replacing the import from react-redux to @react-nano/redux!\n","title":"Migrating From react-redux","projectIndex":{"title":"redux","url":"https://lusito.github.io/react-nano/redux/"}},{"url":"https://lusito.github.io/react-nano/redux/provider.html","content":"Provider\nAdding a Provider\nIn order to get access to your redux store, you'll need to wrap your app in a (single) provider like this:\nimport { Provider } from \"@react-nano/redux\";\nexport const App = () => <Provider store={store}>...</Provider>;\n\n","title":"Provider","projectIndex":{"title":"redux","url":"https://lusito.github.io/react-nano/redux/"}},{"url":"https://lusito.github.io/react-nano/redux/setup.html","content":"Setup\nThis library is shipped as es2015 modules. To use them in browsers, you'll have to transpile them using webpack or similar, which you probably already do.\nInstall via NPM\nnpm i @react-nano/redux\n\n","title":"Setup","projectIndex":{"title":"redux","url":"https://lusito.github.io/react-nano/redux/"}},{"url":"https://lusito.github.io/react-nano/redux-dynamic-modules/","content":"@react-nano/redux-dynamic-modules\n\n\n\n\n\nMaking redux-dynamic-modules more lightweight by using @react-nano/redux instead of react-redux.\nWritten in TypeScript.\nWhy Use @react-nano/redux-dynamic-modules?\n\nVery lightweight (see the badges above for the latest size).\nIt still uses redux-dynamic-modules(-core) under the hood (as a peer dependency), so you'll stay up to date with the latest features and bugfixes!\nAll it does is supply a different DynamicModuleLoader component which leverages the power of hooks in combination with @react-nano/redux.\nAll other imports can be taken from redux-dynamic-modules-core instead of redux-dynamic-modules.\nOnly has four peer dependencies:\n\nReact 17.0.0 or higher\nRedux 4.0.0 or higher\n@react-nano/redux in the same version\nredux-dynamic-modules-core 5.0.0 or higher\n\n\nLiberal license: zlib/libpng\n\nNote: Since this library uses @react-nano/redux, your code also needs to be using @react-nano/redux (otherwise you'd be using redux-dynamic-modules).\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"redux-dynamic-modules","projectIndex":{"title":"redux-dynamic-modules","url":"https://lusito.github.io/react-nano/redux-dynamic-modules/"}},{"url":"https://lusito.github.io/react-nano/redux-dynamic-modules/setup.html","content":"Setup\nThis library is shipped as es2015 modules. To use them in browsers, you'll have to transpile them using webpack or similar, which you probably already do.\nInstall via NPM\nnpm i @react-nano/redux-dynamic-modules\n\nDynamicModuleLoader\nIt works just like the original. You only need to adjust the import statement:\nimport { DynamicModuleLoader } from \"@react-nano/redux-dynamic-modules\";\nexport const MyComponent = () => <DynamicModuleLoader modules={[myModule()]}>....</DynamicModuleLoader>;\n\n","title":"Setup","projectIndex":{"title":"redux-dynamic-modules","url":"https://lusito.github.io/react-nano/redux-dynamic-modules/"}},{"url":"https://lusito.github.io/react-nano/router/","content":"@react-nano/router\n\n\n\n\n\nA simple, lightweight react router using hooks, written in TypeScript.\nWhy Use @react-nano/router?\n\nVery lightweight (see the badges above for the latest size).\nFlexible and dead simple to use.\nUses the browsers history API (no bulky polyfill).\nDoes not force a matching algorithm on you. It's up to you!\n\nComes with a simple (one-liner) matching algorithm built-in for simple use-cases.\n\n\nWritten with hooks in TypeScript\nOnly has one peer dependency: React 17.0.0 or higher.\nLiberal license: zlib/libpng\n\nExample\nA small example might look like this:\nimport { Router } from \"@react-nano/router\";\nexport const App = () => (\n  <Router>\n    <Switch>\n      <Route path=\"/news\" component={News} />\n      <Route path=\"/fakenews\" component={FakeNews} />\n      {/* use \"(.*)\"  instead of \"*\" if you use path-to-regexp */}\n      <Route path=\"*\" component={Otherwise} />\n    </Switch>\n  </Router>\n);\n\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"router","projectIndex":{"title":"router","url":"https://lusito.github.io/react-nano/router/"}},{"url":"https://lusito.github.io/react-nano/router/hooks.html","content":"Hooks\nuseParams\nIn some cases you want to extract parameters without being in a Route component.\nYou can get a memoized parameters object for the given path like this:\nexport const Component = () => {\n  const params = useParams<{ id: string }>(\"/news/:id\");\n  //...\n};\n\nuseRouter\nRouter internally adds a RouterContext to your application, which you can access using the useRouter() hook:\nimport { useRouter } from \"@react-nano/router\";\n...\nexport function Component() {\n    // router is of type RouterContextValue (see below)\n    const router = useRouter();\n    ....\n}\n\nRouterContextValue is defined as:\nexport interface RouterContextValue {\n  basename: string;\n  path: string;\n  history: RouterHistory;\n  matchRoute: CachedRouteMatcher;\n  urlTo: (path: string) => string;\n}\n// with:\nexport interface RouterHistory {\n  push: (path: string) => void;\n  replace: (path: string) => void;\n  stop: () => void; // for internal use, do not call.\n  urlTo: (path: string) => string;\n}\n// and:\nexport type CachedRouteMatcher = (pattern: string, path: string) => RouteParams | null;\n\nurlTo() can be used to create a new url, which respects basename and mode. It's the same for both RouterContextValue and RouterHistory.\n","title":"Hooks","projectIndex":{"title":"router","url":"https://lusito.github.io/react-nano/router/"}},{"url":"https://lusito.github.io/react-nano/router/links.html","content":"Links, Etc.\nLink\nThe Link component can be used to change the url and still act as a normal <a> tag, so you can open the link in a new tab.\nexport const Component = () => <Link href=\"/hello\">Test</Link>;\n\nAny extra props you pass in will be forwarded to the <a> element. If you specify an onClick property and it calls preventDefault(), then the history change will not happen, as would be the case with any normal link.\nLinkButton, Etc.\nIf you want to create a LinkButton or similar, you can do that easily. This is the implementation of Link:\nexport function Link(props: React.PropsWithChildren<LinkProps>) {\n  const routeLink = useRouteLink(props.href, props.onClick);\n  return <a {...props} href={routeLink.href} onClick={routeLink.onClick} />;\n}\n\nCreating a LinkButton is as simple as this:\nimport { useRouteLink } from \"@react-nano/router\";\n...\nexport function LinkButton(props: React.PropsWithChildren<LinkButtonProps>) {\n    const routeLink = useRouteLink(props.href, props.onClick);\n    return <button {...props} onClick={routeLink.onClick} />;\n}\n\n","title":"Links, Etc.","projectIndex":{"title":"router","url":"https://lusito.github.io/react-nano/router/"}},{"url":"https://lusito.github.io/react-nano/router/router.html","content":"Router\nYou'll need to add a Router component in your app (just one). Any other components and hooks from this library need to be children of this Router (doesn't matter how deeply nested).\nimport { Router } from \"@react-nano/router\";\nexport const App = () => <Router>....</Router>;\n\nStoring the Route in the Hash\nIn some situations, it's easier to store the route in the hash part of the URL, as it avoids the server having to be aware of the single page application behavior. You can enable the \"hash\" mode on the Router component:\nimport { Router } from \"@react-nano/router\";\nexport const App = () => <Router mode=\"hash\">....</Router>;\n\nThis will result in a url like https://some-domain.com/#/News instead of https://some-domain.com/News.\nThis approach will still use the history API internally!\nUsing a Basename\nIf your app is not located at the root directory of a server, but instead in a sub-directory, you'll want to specify that sub-directory. Basename will then automatically be prefixed on Link components.\nimport { Router } from \"@react-nano/router\";\nexport const App = () => <Router basename=\"/my-app\">....</Router>;\n\nIf you have a <base> tag in your HTML, this can be easily detected using the getBasename() helper. That way you don't have to hard-code it:\nimport { Router, getBasename } from \"@react-nano/router\";\nexport const App = () => <Router basename={getBasename()}>....</Router>;\n\nCustom Route Matching\nThis library doesn't force a route matching algorithm on you, but it comes with a lightweight one built-in.\nThe built-in route matching algorithm only allows exact matches and a \"match everything\" (\"*\") though.\nIf you need something more sophisticated, you'll have to supply a factory. Here is a simple example using the popular path-to-regexp library:\nimport { pathToRegexp, Key } from \"path-to-regexp\";\nimport { Router, RouteParams } from \"@react-nano/router\";\n\nfunction routeMatcherFactory(pattern: string) {\n  const keys: Key[] = [];\n  const regex = pathToRegexp(pattern, keys);\n\n  return (path: string) => {\n    const out = regex.exec(path);\n\n    if (!out) return null;\n\n    return keys.reduce((params, key, i) => {\n      params[key.name] = out[i + 1];\n      return params;\n    }, {} as RouteParams);\n  };\n}\n\nexport const App = () => <Router routeMatcherFactory={routeMatcherFactory}>....</Router>;\n\nUsing pathToRegexp allows to extract named parameters from a pattern like \"/users/:name\".\nI.e. if the path is \"/users/Zaphod\", then the param with the key \"name\" would have the value \"Zaphod\".\n","title":"Router","projectIndex":{"title":"router","url":"https://lusito.github.io/react-nano/router/"}},{"url":"https://lusito.github.io/react-nano/router/routes.html","content":"Routes\nRoute\nShowing a component if the location matches a certain path is done with a Route component. It takes a path prop and either a component prop or children.\nexport const Component = () => (\n  <div>\n    <Route path=\"/news\" component={News} />\n    <Route path=\"/fakenews\">Drumpf</Route>\n  </div>\n);\n\nBeware: If multiple routes have a matching path, all will be shown. Use a Switch component if that's not desired.\nAs you can see, it's possible to specify a component to render or normal children.\nYou can even use a callback instead of children like this:\nexport const Component = () => (\n    <Route path=\"/foo/:id\">{(params: { id: string }) => <div>Bar {params.id}</div>}</Route>;\n);\n\nSee further below for the the possibility of using parameters.\nSwitch\nIf you only want the first Route that has a matching path to be shown, you can use a Switch:\nexport const Component = () => (\n  <Switch>\n    <Route path=\"/news\" component={News} />\n    <Route path=\"/fakenews\" component={FakeNews} />\n    {/* use \"(.*)\"  instead of \"*\" if you use path-to-regexp */}\n    <Route path=\"*\" component={Otherwise} />\n  </Switch>\n);\n\nNote: The path pattern for the \"Otherwise\" Route differs depending on your route matching algorithm. With the built-in simpleRouteMatcherFactory you would use \"*\", while you would use \"(.*)\" or \"/:fallback\" for path-to-regexp.\nAdding Parameters\nWhen you use a custom matching algorithm like path-to-regexp, you can extract values from the path. Let's say you have this route:\nexport const Component = () => <Route path=\"/news/:id\" component={News} />;\n\nYou defined a parameter :id in your path. Now you can access it in your News component:\nexport const News = (props: RouteComponentProps<{ id: string }>) => <div>News ID: {props.params.id}</div>;\n\nFresh Rendering\nLet's say you have this route:\nexport const Component = () => <Route path=\"/news/:id\" component={News} />;\n\nMoving from /news/1 to /news/2 will only update the components properties. State will be preserved.\nIf you want to force the component to be created from scratch in this situation, you can do so by setting the property addKey (boolean).\nThis will add the key property to the component with a value of the current path.\n","title":"Routes","projectIndex":{"title":"router","url":"https://lusito.github.io/react-nano/router/"}},{"url":"https://lusito.github.io/react-nano/router/setup.html","content":"Setup\nThis library is shipped as es2015 modules. To use them in browsers, you'll have to transpile them using webpack or similar, which you probably already do.\nInstall via NPM\nnpm i @react-nano/router\n\n","title":"Setup","projectIndex":{"title":"router","url":"https://lusito.github.io/react-nano/router/"}},{"url":"https://lusito.github.io/react-nano/tsrux/","content":"@react-nano/tsrux\n\n\n\n\n\n@react-nano/tsrux enables you to reduce the redux boilerplate code you usually write to define your action creators, reducers, etc. and even gain type-safety in the process!\nThe name stands for type-safe redux, aside from the bloody obvious: TypeScript Rocks!\nWhy Use @react-nano/tsrux?\n\nExtremely lightweight: 300 byte vs 7.7 kilobyte for deox.\nDeadsimple to use\nNo dependencies!\nFully documented\nAutomated unit- and type tests\nLiberal license: zlib/libpng\n\nExample: Actions Creators\n// No payload:\nexport const fetchTodos = actionCreator(\"TODOS/FETCH\");\n// With payload:\nexport const addTodo = actionCreator(\"TODOS/ADD\", (label: string) => ({ label }));\n// With payload and metadata:\nexport const removeTodo = actionCreator(\n  \"TODOS/REMOVE\",\n  (id: number) => ({ id }),\n  (id: number) => ({ metaId: id, foo: \"bar\" }),\n);\n\nfind out more\nExample: Reducers\nexport const todosReducer = mapReducers(initialState, (handle) => [\n    handle(addTodo, (state, action) => ({\n        ...state,\n        list: [...state.list, { id: state.nextId, label: action.payload.label, checked: false }],\n        nextId: state.nextId + 1,\n    })),\n    ...\n]);\n\nfind out more\nHow to Use\nCheck out the documentation\nSimilar Projects\nThis package is heavily inspired by deox, but uses a more lightweight approach.\nAside from that, there are redux-actions and typesafe-actions.\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"tsrux","projectIndex":{"title":"tsrux","url":"https://lusito.github.io/react-nano/tsrux/"}},{"url":"https://lusito.github.io/react-nano/tsrux/action-creators.html","content":"Action Creators\nAction creators are used to easily create actions. Defining action creators enables us to use their types in reducers!\nWithout Payload and Metadata\nThe first parameter of actionCreator() is the type of the action.\nIf you don't specify further parameters, the returned function receives no arguments:\nimport { actionCreator } from \"@react-nano/tsrux\";\n\nconst fetchTodos = actionCreator(\"TODOS/FETCH\");\n\n// When called returns: { type: \"TODOS/FETCH\" }\nconsole.log(fetchTodos());\n\n// Has a static property type=\"TODOS/FETCH\"\nconsole.log(fetchTodos.type);\n\nWith Payload, but Without Metadata\nThe second, optional parameter of actionCreator() is a factory function to create the payload of the action.\nIf you specify it, the returned function receives the same arguments as your factory function:\nimport { actionCreator } from \"@react-nano/tsrux\";\n\nconst setTodoChecked = actionCreator(\"TODOS/SET_CHECKED\", (id: number, checked: boolean) => ({ id, checked }));\n\n// When called returns: { type: \"TODOS/SET_CHECKED\", payload: { id: 42, checked: true } }\nconsole.log(setTodoChecked(42, true));\n\nWith Payload and Metadata\nThe third, optional parameter of actionCreator() is a factory function to create the metadata of the action.\nIf you specify it, the returned function receives the same arguments as your factory function. As such, it must have the same signature as your payload factory:\nimport { actionCreator } from \"@react-nano/tsrux\";\n\nconst removeTodo = actionCreator(\n  \"TODOS/REMOVE\",\n  (id: number) => ({ id }),\n  (id: number) => ({ metaId: id, foo: \"bar\" }),\n);\n\n// When called returns: { type: \"TODOS/REMOVE\", payload: { id: 42 }, meta: { metaId: id, foo: \"bar\" } }\nconsole.log(removeTodo(42));\n\nWithout Payload, but With Metadata\nOf course, you can also leave out the payload factory:\nimport { actionCreator } from \"@react-nano/tsrux\";\n\nconst removeTodo = actionCreator(\"TODOS/FOO\", undefined, (id: number) => ({ metaId: id, foo: \"bar\" }));\n\n// When called returns: { type: \"TODOS/FOO\", meta: { metaId: id, foo: \"bar\" } }\nconsole.log(removeTodo(42));\n\n","title":"Action Creators","projectIndex":{"title":"tsrux","url":"https://lusito.github.io/react-nano/tsrux/"}},{"url":"https://lusito.github.io/react-nano/tsrux/reducers.html","content":"Reducers\nReducers apply your actions to the state.\nInitial State\nFirst, you'll need to create an initial state. Some typing might be required here, some can be infered:\nimport { mapReducers } from \"@react-nano/tsrux\";\n\n// Some types, you obviously still need\ninterface TodoEntry {\n  id: number;\n  label: string;\n  checked: boolean;\n}\n\nconst initialState = {\n  list: [] as TodoEntry[],\n  nextId: 0,\n};\n\n// Some types you can infer from a variable\nexport type TodoState = typeof initialState;\n\nHandle Actions\nWhen using mapReducers(), you don't need to define any more types!\n\nThis function is used to create a reducer for multiple actions.\nIt receives the initial state and a callback.\n\nThe callback is used to set up action handlers and returns an array of action handlers.\n\n\n\nexport const todosReducer = mapReducers(initialState, (handle) => [\n  // handle(actionCreator, reducer) helps you define a reducer responsible for one single action.\n  // Both state and action know their types without needing to manually specify them!\n  handle(addTodo, (state, action) => ({\n    ...state,\n    list: [...state.list, { id: state.nextId, label: action.payload.label, checked: false }],\n    nextId: state.nextId + 1,\n  })),\n  handle(setTodoChecked, (state, action) => ({\n    ...state,\n    list: state.list.map((todo) => {\n      if (todo.id === action.payload.id) return { ...todo, checked: action.payload.checked };\n      return todo;\n    }),\n  })),\n  handle(removeTodo, (state, action) => ({\n    ...state,\n    // Complains about next line: payload does not have an attribute named \"ID\"\n    list: state.list.filter((todo) => todo.id !== action.payload.ID),\n  })),\n]);\n\n","title":"Reducers","projectIndex":{"title":"tsrux","url":"https://lusito.github.io/react-nano/tsrux/"}},{"url":"https://lusito.github.io/react-nano/tsrux/further-examples.html","content":"Further Examples\nConfigure Store\nYou might be used to a configureStore function from libraries like deox. @react-nano/tsrux does not provide one for a good reason:\nThere are already projects out there providing these. Depending on your other libraries you might already have one.\nHere are some references:\n\n@reduxjs/toolkit (formerly known as redux-starter-kit)\nredux-dynamic-modules, an awesome library if you are planning to modularize your code.\n\nCombine Reducers\n@react-nano/tsrux is compatible with combineReducers from redux.\nCreate Store\n@react-nano/tsrux is compatible with createStore from redux.\nRedux Saga\n@react-nano/tsrux is compatible with redux-saga and reduces boilerplate code here as well:\nimport { ActionOf } from \"@react-nano/tsrux\";\nimport { addTodo } from \"./actions\";\n\nfunction* todosSaga() {\n  yield takeEvery(addTodo.type, addTodoSaga);\n}\n\nfunction* addTodoSaga(action: ActionOf<typeof addTodo>) {\n  //...\n}\n\nRedux Thunk\nNo special knowledge required to use redux thunk with @react-nano/tsrux.\n","title":"Further Examples","projectIndex":{"title":"tsrux","url":"https://lusito.github.io/react-nano/tsrux/"}},{"url":"https://lusito.github.io/react-nano/tsrux/setup.html","content":"Setup\nThis library is shipped as es2015 modules. To use them in browsers, you'll have to transpile them using webpack or similar, which you probably already do.\nInstall via NPM\nnpm i @react-nano/tsrux\n\nRedux\nYou will need redux to use @react-nano/tsrux, but since you got here, you most likely already use redux.\nActually, you don't need redux specifically, since @react-nano/tsrux has no dependency on redux. You could use any other library that uses the same API for actions and reducers!\n","title":"Setup","projectIndex":{"title":"tsrux","url":"https://lusito.github.io/react-nano/tsrux/"}},{"url":"https://lusito.github.io/react-nano/tsrux/types.html","content":"Additional Types\nSome convenience types are included for the rare case where you do need to write types.\nPrefer typeof\nIn a lot of situations you can get the types using typescripts typeof keyword.\nFor example, if you want to get the type of an actionCreator:\ntype AddTodoActionCreator = typeof addTodo;\n\nActionOf\ntype ActionOf<TActionCreator extends ActionCreator<any, any, any>>\n\nThis can be used to determine the Action type by inspecting an action-creator:\ntype AddTodoAction = ActionOf<typeof addTodo>;\n\nAction\nUse this type if you need to manually define the type of an action:\ntype Action<TType extends string, TPayload = undefined, TMeta = undefined>\n\nAnyAction\ntype AnyAction\n\nAny action can be assigned to this type.\nActionCreator\ntype ActionCreator<\n    TType extends string,\n    TAction extends Action<TType, any, any>,\n    TParams extends any[] = any[]\n>\n\nThis describes the type of an action creator. It is mostly for internal use.\n","title":"Additional Types","projectIndex":{"title":"tsrux","url":"https://lusito.github.io/react-nano/tsrux/"}},{"url":"https://lusito.github.io/react-nano/use-event-source/","content":"@react-nano/use-event-source\n\n\n\n\n\nA lightweight EventSource (server-sent-events) hook for react, written in TypeScript.\nWhy Use @react-nano/use-event-source?\n\nVery lightweight (see the badges above for the latest size).\nFlexible and dead simple to use.\nWritten in TypeScript\nOnly has one required peer dependency: React 17.0.0 or higher.\nLiberal license: zlib/libpng\n\nBeware: This is currently work in progress. The API might change.\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"use-event-source","projectIndex":{"title":"use-event-source","url":"https://lusito.github.io/react-nano/use-event-source/"}},{"url":"https://lusito.github.io/react-nano/use-event-source/redux.html","content":"Usage with Redux\nExample\nYou can just as easily combine it with redux:\nimport { useEventSource, useEventSourceListener } from \"@react-nano/use-event-source\";\nimport { Action, Store } from \"redux\";\nimport { useStore } from \"@react-nano/redux\"; // or: \"react-redux\";\n\nfunction MyComponent() {\n  const messages = useSelector(getMessages);\n  const dispatch = useDispatch();\n  const [eventSource, eventSourceStatus] = useEventSource(\"api/events\", true);\n  useEventSourceListener(\n    eventSource,\n    [\"update\"],\n    (evt) => {\n      dispatch(addMessages(JSON.parse(evt.data)));\n    },\n    [dispatch],\n  );\n\n  return (\n    <div>\n      {eventSourceStatus === \"open\" ? null : <BusyIndicator />}\n      {messages.map((msg) => (\n        <div>{msg.text}</div>\n      ))}\n    </div>\n  );\n}\n\n","title":"Usage with Redux","projectIndex":{"title":"use-event-source","url":"https://lusito.github.io/react-nano/use-event-source/"}},{"url":"https://lusito.github.io/react-nano/use-event-source/usage.html","content":"Usage\nExample\nIn order to subscribe to an SSE endpoint, you need to call useEventSource.\nAfter you have it, you can add listeners to it. Here's a simple example:\nimport { useEventSource, useEventSourceListener } from \"@react-nano/use-event-source\";\n\nfunction MyComponent() {\n  const [messages, addMessages] = useReducer(messageReducer, []);\n\n  const [eventSource, eventSourceStatus] = useEventSource(\"api/events\", true);\n  useEventSourceListener(\n    eventSource,\n    [\"update\"],\n    (evt) => {\n      addMessages(JSON.parse(evt.data));\n    },\n    [addMessages],\n  );\n\n  return (\n    <div>\n      {eventSourceStatus === \"open\" ? null : <BusyIndicator />}\n      {messages.map((msg) => (\n        <div>{msg.text}</div>\n      ))}\n    </div>\n  );\n}\n\nuseEventSource\nThis describes the entire API of the useEventSource hook:\n// Create an EventSource\nfunction useEventSource(\n    // The url to fetch from\n    url: string,\n    // Send credentials or not\n    withCredentials?: boolean,\n    // Optionally override the EventSource class (for example with a polyfill)\n    ESClass: EventSourceConstructor = EventSource\n) => [\n    // The generated EventSource.. on first call, it will be null.\n    EventSource | null,\n    // The status of the connection can be used to display a busy indicator, error indicator, etc.\n    EventSourceStatus\n];\n\ntype EventSourceStatus = \"init\" | \"open\" | \"closed\" | \"error\";\n\nuseEventSourceListener\nThis describes the entire API of the useEventSourceListener hook:\n// Add a listener to the EventSource\nfunction useEventSourceListener(\n    // The EventSource from the above hook\n    source: EventSource | null,\n    // The event types to add the listener to\n    types: string[],\n    // A listener callback (use e.type to get the event type)\n    listener: (e: EventSourceEvent) => void,\n    // If one of the dependencies changes, the listener will be re-added to the event types.\n    dependencies: any[] = []\n) => void;\n\n\n","title":"Usage","projectIndex":{"title":"use-event-source","url":"https://lusito.github.io/react-nano/use-event-source/"}},{"url":"https://lusito.github.io/react-nano/use-event-source/setup.html","content":"Setup\nThis library is shipped as es2015 modules. To use them in browsers, you'll have to transpile them using webpack or similar, which you probably already do.\nInstall via NPM\nnpm i @react-nano/use-event-source\n\n","title":"Setup","projectIndex":{"title":"use-event-source","url":"https://lusito.github.io/react-nano/use-event-source/"}},{"url":"https://lusito.github.io/react-nano/use-graphql/","content":"@react-nano/use-graphql\n\n\n\n\n\nA lightweight, type-safe graphql hook for react, written in TypeScript.\nWhy Use @react-nano/use-graphql?\n\nVery lightweight (see the badges above for the latest size).\nFlexible and dead simple to use.\nWritten in TypeScript\nType-safe results (tested with tsd)\nAutocompletion while writing query definitions\nOnly has one required peer dependency: React 17.0.0 or higher.\nLiberal license: zlib/libpng\n\nThis is no code-generator. It works purely by using TypeScript 4.1 features.\n\nNo Query Strings\nDon't write query strings manually. Write TypeScript and get autocompletion for free!\nType-Safe\nInstead of getting the full interface as a result type from a query/mutation, you only get those fields you actually selected in your hook definition!\nEasy to Use\nWrite your types, define queries/mutations, use the hook, display data => done!\n\nThis is a Work In Progress! The API might change before version 1.0 is released.\nSimple Example\nIn your component file, define your customized GraphQL hook and use it in the component:\nimport React from \"react\";\nimport { graphQL } from \"@react-nano/use-graphql\";\nimport { UserDTO, ErrorDTO, queryUserVariableTypes } from \"../types\";\n\n// No need to write the query as string. Write it in TypeScript and get autocompletion for free!\nconst useUserQuery = graphQL\n  .query<UserDTO, ErrorDTO>(\"user\")\n  .with(queryUserVariableTypes)\n  .createHook({\n    // These properties will be autocompleted based on the first type argument above\n    name: true,\n    icon: true,\n    posts: {\n      id: true,\n      title: true,\n      hits: true,\n    },\n  });\n\nexport function UserSummary({ id }: UserSummaryProps) {\n  // It is possible to supply the url globally using a provider\n  // autoSubmit results in the request being send instantly. You can trigger it manually as well.\n  const [userState] = useUserQuery({ url: \"/graphql\", autoSubmit: { id } });\n\n  // There is more state information available. This is just kept short for an overview!\n  if (!userState.success) return <div>Loading</div>;\n\n  // Unless you checked for userState.state === \"success\" (or userState.success), userState.data will not exist on the type.\n  const user = userState.data;\n  return (\n    <ul>\n      <li>Name: {user.name}</li>\n      <li>\n        Icon: <img src={user.icon} alt=\"User Icon\" />\n      </li>\n      <li>Age: {user.age /* Error: No property 'age' on user! */}</li>\n      <li>\n        Posts:\n        <ul>\n          {user.posts.map((post) => (\n            <li key={post.id}>\n              {post.title} with {post.hits} hits\n            </li>\n          ))}\n        </ul>\n      </li>\n    </ul>\n  );\n}\n\nIn the above example, the type of userState.data is automatically created by inspecting the attribute choices specified in the fields definition of your hook.\nSo, even though UserDTO specifies the properties id and age and PostDTO specifies message and user, they will not end up in the returned data type and will lead to a compile-time error when you try to access them. For all other properties you will get autocompletion and type-safety.\nTo use the above example, you'll need to define your full types somewhere (i.e. all types and attributes that could possibly be requested):\nimport { GraphGLVariableTypes } from \"@react-nano/use-graphql\";\n\nexport interface ErrorDTO {\n    message: string;\n}\n\nexport interface PostDTO {\n    id: number;\n    title: string;\n    message: string;\n    hits: number;\n    user: UserDTO;\n}\n\nexport interface UserDTO {\n    id: string;\n    name: string;\n    icon: string;\n    age: number;\n    posts: PostDTO[];\n}\n\nexport interface QueryUserVariables {\n    id: string;\n}\n\n// Also specify GraphQL variable types as a constant like this:\nconst queryUserVariableTypes: GraphGLVariableTypes<QueryUserVariables> = {\n    // These will be autocompleted (and are required) based on the type argument above\n    // The values here are the only place where you still need to write GraphQL types.\n    id: \"String!\",\n};\n\n\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"use-graphql","projectIndex":{"title":"use-graphql","url":"https://lusito.github.io/react-nano/use-graphql/"}},{"url":"https://lusito.github.io/react-nano/use-graphql/builder.html","content":"Hook Builder\nSpecifying a Query or Mutation\nThe graphQL builder pattern helps you to define a query or mutation hook, which can then be used in your component.\nThe first thing you do is define the type (query or mutation) and its name like this:\nQuery\nconst useUserQuery = graphQL.query<UserDTO, ErrorDTO>(\"user\");\n// ... see next steps\n\nMutation\nconst useUpdateUserMutation = graphQL.mutation<Partial<UserDTO>, ErrorDTO>(\"updateUser\");\n// ...see next steps\n\nAs you can see, graphQL.query and graphQL.mutation also require two type arguments to be specified:\n\nThe full type that could be returned by the server if all fields had been selected\nThe error type that would be returned by the server in case of an error (the non-array form).\n\nSpecifying Variable Types\nAfter that you can optionally specify variable types for this query/mutation:\n    // ...see previous step\n    .with(queryUserVariableTypes)\n    // ...see next step\n\nSee setup for the definition of queryUserVariableTypes.\nCreating the Hook\nThe final step is to create a hook, which can then be used in your components.\n\nIf your request returns a primitive or an array of primitives like number, string or string[], you obviously can't select any fields, so createHook takes no arguments.\nOtherwise the first (and only) argument is an object with true for each attribute and an object for the relations you want to get returned (similarly to a GraphQL query string):\n\nNon-Primitive Return Type\n    // ...see previous steps\n    .createHook({\n        // These properties will be autocompleted based on the first type argument of the query call above\n        name: true,\n        icon: true,\n        posts: {\n            id: true,\n            title: true,\n            hits: true,\n        },\n    });\n\nPrimitive Return Type\n    // ...see previous steps\n    .createHook();\n\nExamples\nHere are two full examples:\nComplex Type With Variables\nimport { graphQL } from \"@react-nano/use-graphql\";\n// See \"Setup\" section for these types\nimport { UserDTO, ErrorDTO, queryUserVariableTypes } from '../types';\n\n// No need to write the query as string. Write it in TypeScript and get autocompletion for free!\nconst useUserQuery = graphQL\n    .query<UserDTO, ErrorDTO>(\"user\")\n    .with(queryUserVariableTypes)\n    .createHook({\n        // These properties will be autocompleted based on the first type argument of the query call above\n        name: true,\n        icon: true,\n        posts: {\n            id: true,\n            title: true,\n            hits: true,\n        }\n    });\n\n\nPrimitive Type Without Variables\nimport { graphQL } from \"@react-nano/use-graphql\";\n\nconst useUserNamesQuery = graphQL.query<string[], ErrorDTO>(\"userNames\").createHook();\n\n","title":"Hook Builder","projectIndex":{"title":"use-graphql","url":"https://lusito.github.io/react-nano/use-graphql/"}},{"url":"https://lusito.github.io/react-nano/use-graphql/config.html","content":"Configurations\nIt's possible to supply configurations both globally (via provider) and locally (as argument to your query/mutation hook).\nBoth configurations have the same attributes, except that the local config has one additional property autoSubmit.\nLocal Configuration\nLet's take a look at the local configuration first:\nexport interface GraphQLConfig<TData, TError extends Record<string, any>, TVars> {\n    /** The url to use. Defaults to \"/graphql\" if neither global nor local config specifies it */\n    url?: string;\n\n    /**\n     * Called right before a request will be made. Use it to extend the request with additional information like authorization headers.\n     *\n     * @param init The request data to be send.\n     */\n    onInit?(init: RequestInit & GraphQLRequestInit): void;\n\n    /**\n     * Called on successful request with the result\n     *\n     * @param context Information about the request\n     */\n    onSuccess?(context: OnSuccessContext<TVars, TData>): void;\n\n    /**\n     * Called on server error\n     *\n     * @param context Information about the request\n     */\n    onError?(context: OnErrorContext<TVars, TError>): void;\n\n    /**\n     * Called when an exception happened in the frontend\n     *\n     * @param context Information about the request\n     */\n    onException?(context: OnExceptionContext<TVars>): void;\n}\n\nexport interface GraphQLLocalConfig<TData, TError extends Record<string, any>, TVars extends VariableType>\n    extends GraphQLConfig<TData, TError, TVars> {\n    /** Specify to cause the request to be submitted automatically */\n    autoSubmit?: TVars extends null ? true : TVars;\n}\n\n\nAll of the properties are optional.\nSpecify autoSubmit if you want to send the request on component mount without having to call its submit function manually.\n\nThe value is expected to be true for requests without variables and a variable object otherwise.\n\n\nSpecify callbacks for certain events instead of watching the state object in a useEffect Hook.\n\nThe hook will always use the latest version of the callbacks.\nIf the component making the request has been unmounted, the callbacks will not be called.\n\n\nTake a look at the hook description hook to see how to specify this config.\n\nCallback Context\nThe context parameter has different properties depending on the callback:\nexport interface CallbackContext<TVars> {\n    /** The data you used to submit the request */\n    inputData: TVars;\n}\n\nexport interface CallbackContextWithResponse<TVars> extends CallbackContext<TVars> {\n    /** The status code of the request */\n    status: number;\n    /** The response headers headers of the request */\n    responseHeaders: Headers;\n}\n\nexport interface OnSuccessContext<TVars, TData> extends CallbackContextWithResponse<TVars> {\n    /** The result of the query/mutation */\n    data: TData;\n}\n\nexport interface OnErrorContext<TVars, TError> extends CallbackContextWithResponse<TVars> {\n    /** The errors the server returned for the query/mutation */\n    errors: TError[];\n}\n\nexport interface OnExceptionContext<TVars> extends CallbackContext<TVars> {\n    /** The error that was thrown. */\n    error: Error;\n}\n\nGlobal Configuration\nYou can specify a global configuration by wrapping your app content in a provider:\nfunction MyApp {\n    return (\n        <GraphQLGlobalConfigProvider value={{\n            onInit(init) {\n                init.headers.set(\"authorization\", token);\n            },\n            onException(error) {\n                console.log(\"Exception during GraphQL request\", error);\n            },\n            ...\n        }}>\n            ...The app content\n        </GraphQLGlobalConfigProvider>\n    );\n}\n\nAs said, the only difference between local and global configurations is the autoSubmit property in local configurations.\n\nThis means, that you can specify the url globally, but you can override it locally if you need to.\nCallbacks on the other hand will run both globally and locally.\n\nKeep in mind, that some of the types are different for each query/mutation, so you'll have to manually cast the data if you need access to it.\nMost common scenarios for using the callbacks globally:\n\nAdding authorization headers to the request\nLogging and/or showing toast messages on success/error/exception events\n\n\nJust as with local callbacks: If the component making the request has been unmounted, the callbacks will not be called.\n\n\n\n","title":"Configurations","projectIndex":{"title":"use-graphql","url":"https://lusito.github.io/react-nano/use-graphql/"}},{"url":"https://lusito.github.io/react-nano/use-graphql/hook.html","content":"Your GraphQL Hook\nUsing the Hook\nThe hook you build using the hook builder allows you to perform a GraphQL request from within a react component.\nIt takes an optional config object and returns a tuple with 3 elements:\n\nA state object containing information about the request and possibly the results or errors\nA submit function if you want to run the request manually\nAn abort function if you want to abort the request manually (it will be aborted automatically when the component gets unmounted).\n\nAll of this completely type-safe!\nExample\nimport { graphQL } from \"@react-nano/use-graphql\";\n\n// See the examples in the \"Hook Builder\" section.\nconst useUserQuery = graphQL.query(\"user\")...;\n\nexport function UserSummary({ id }: UserSummaryProps) {\n    const [userState] = useUserQuery({ url: \"/graphql\", autoSubmit: { id } });\n\n    if (!userState.success) return <div>Loading</div>;\n\n    const user = userState.data;\n    return (\n        <ul>\n            <li>Name: {user.name}</li>\n            <li>Icon: <img src={user.icon} alt=\"User Icon\" /></li>\n            <li>Posts:\n                <ul>\n                    {user.posts.map((post) => (\n                        <li key={post.id}>{post.title} with {post.hits} hits</li>\n                    ))}\n                </ul>\n            </li>\n        </ul>\n    );\n}\n\nThe State Object\nThe state object always has these properties:\n\nloading: boolean => Request is currently in progress\nfailed: boolean; => Either an exception occurred or the request returned an error\nsuccess: boolean; => Request was successful\ntype: \"empty\" | \"success\" | \"error\" | \"exception\" => The last known state of the request (a new request might be in progress)\n\nDepending on type, additional properties might be available:\n\n\"empty\" => This is the initial state if no request has returned yet\n\nfailed will always be false\nsuccess will always be false\n\n\n\"success => This is the state when a request returned successful.\n\nfailed will always be false\nsuccess will always be true\nresponseStatus: number; => The status code of the response\nresponseHeaders: Headers; => The headers of the response\ndata: ResultType => The server result\n\n\n\"error\" => The server responded with an error.\n\nfailed will always be true\nsuccess will always be false\nresponseStatus: number; => The status code of the response\nresponseHeaders: Headers; => The headers of the response\nerrors: ErrorType[]; => The list of errors returned by the server\n\n\n\"exception\" => An exception has been thrown in JavaScript\n\nfailed will always be true\nsuccess will always be false\nerrors: Error; => The error that has been thrown\n\n\n\nThe Submit Function\nThe submit function arguments depend on wether you defined variables in your hook:\n\nIf you defined variables, you'll need to pass them as an object to the submit function.\n\nE.g. submit({ id: \"hello\" });\n\n\nOtherwise, call the submit function without arguments.\n\nThe Abort Function\nThis function is simple. It takes no arguments and stops the request.\n","title":"Your GraphQL Hook","projectIndex":{"title":"use-graphql","url":"https://lusito.github.io/react-nano/use-graphql/"}},{"url":"https://lusito.github.io/react-nano/use-graphql/setup.html","content":"Setup\nThis library is shipped as es2015 modules. To use them in browsers, you'll have to transpile them using webpack or similar, which you probably already do.\nTypeScript\nEnsure you have at least TypeScript 4.1 in your setup.\nInstall via NPM\nnpm i @react-nano/use-graphql\n\nDefine Types\nDefine your full types somewhere (i.e. all types and attributes that could possibly be requested, including their relations), for example:\nimport { GraphGLVariableTypes } from \"@react-nano/use-graphql\";\n\nexport interface ErrorDTO {\n    message: string;\n}\n\nexport interface PostDTO {\n    id: number;\n    title: string;\n    message: string;\n    hits: number;\n    user: UserDTO;\n}\n\nexport interface UserDTO {\n    id: string;\n    name: string;\n    icon: string;\n    age: number;\n    posts: PostDTO[];\n}\n\nexport interface QueryUserVariables {\n    id: string;\n}\n\n// Also specify GraphQL variable types as a constant like this:\nconst queryUserVariableTypes: GraphGLVariableTypes<QueryUserVariables> = {\n    // These will be autocompleted (and are required) based on the type argument above\n    // The values here are the only place where you still need to write GraphQL types.\n    id: \"String!\",\n};\n\n\n","title":"Setup","projectIndex":{"title":"use-graphql","url":"https://lusito.github.io/react-nano/use-graphql/"}},{"url":"https://lusito.github.io/react-nano/use-fetch/","content":"@react-nano/use-fetch\n\n\n\n\n\nLightweight fetching hooks for react, written in TypeScript.\nWhy Use @react-nano/use-fetch?\n\nVery lightweight (see the badges above for the latest size).\nFlexible and dead simple to use.\nWritten in TypeScript\nOnly has one required peer dependency: React 17.0.0 or higher.\nLiberal license: zlib/libpng\n\nBeware: This is currently work in progress. The API might change.\nThere are a lot of similar hooks out there, but they either lacked something I needed or seemed overly complicated to use.\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\n@react-nano has been released under the zlib/libpng license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"use-fetch","projectIndex":{"title":"use-fetch","url":"https://lusito.github.io/react-nano/use-fetch/"}},{"url":"https://lusito.github.io/react-nano/use-fetch/api.html","content":"API\ncreateFetchHook\n\ncreateFetchHook creates a type-safe hook that you can use to perform the fetch.\nit takes an object with 3 attributes:\n\nprepare is a function used to prepare the init object you would pass to a fetch call.\n\nthe first parameter is the init object you can modify.\nits (optional) second parameter can be an object of your liking\nthe return value should be the URL you want to run this fetch against.\n\n\ngetResult is a function called to get the result of a response and also to specify the type of the data. Always add a as Promise<MyType> at the end to define your type.\ngetError is essentially the same, but for the case where response.ok === false. I.e. you can have a different type for non-ok responses.\n\n\n\nYour Custom Hooks\n\nThe hook created by createFetchHook gets an optional config parameter with these optional properties:\n\nOne or more of these callbacks: onInit, onSuccess, onError, onException.\n\nSee config for more details\n\n\nA parameter autoSubmit, which can be used to automatically submit the request on component mount\n\nSet this to true if your prepare function does not take a data parameter\nOr set this to the data object your prepare function will receive\n\n\n\n\nuseFetch returns an array containing 3 items:\n\nThe current state of the fetch request, containing the result or error data when it's done. See below for more details.\nA submit function, which you can call to manually (re-)submit the request.\nAn abort function to cancel the active request (it will be automatically called upon unmount).\n\n\n\nFetchState\nThe first entry of the array returned by your custom hook is a state object. Depending on its state property, it can have more properties:\n// These properties are always available\nexport interface FetchStateBase {\n  /** Request is currently in progress */\n  loading: boolean;\n  /** Either an exception occurred or the request returned an error */\n  failed: boolean;\n  /** Request was successful */\n  success: boolean;\n}\n\n// These are only available when the request has not finished yet\nexport interface FetchStateEmpty extends FetchStateBase {\n  state: \"empty\";\n  failed: false;\n  success: false;\n}\n\n// These are available in case of success or error\nexport interface FetchStateDone extends FetchStateBase {\n  /** The status code of the response */\n  responseStatus: number;\n  /** The headers of the response */\n  responseHeaders: Headers;\n}\n\n// These are available in case of success\nexport interface FetchStateDoneSuccess<TData> extends FetchStateDone {\n  failed: false;\n  success: true;\n  /** Data is present */\n  state: \"success\";\n  /** The response data in case of success */\n  data: TData;\n}\n\n// These are available in case of an error\nexport interface FetchStateDoneError<TError extends Record<string, any>> extends FetchStateDone {\n  failed: true;\n  success: false;\n  /** Errors is present */\n  state: \"error\";\n  /** The server result data. */\n  error: TError;\n}\n\n// These are available in case of an exception\nexport interface FetchStateDoneException extends FetchStateBase {\n  failed: true;\n  success: false;\n  /** Errors is present */\n  state: \"exception\";\n  /** The cause of the exception. */\n  error: Error;\n}\n\n// FetchState can be either of the above:\nexport type FetchState<TData, TError extends Record<string, any>> =\n  | FetchStateEmpty\n  | FetchStateDoneSuccess<TData>\n  | FetchStateDoneError<TError>\n  | FetchStateDoneException;\n\nAs you can see, you will only be able to access state.data if you checked for state.success or state.state === \"success\" (or if you ruled out the other possibilities first)\n","title":"API","projectIndex":{"title":"use-fetch","url":"https://lusito.github.io/react-nano/use-fetch/"}},{"url":"https://lusito.github.io/react-nano/use-fetch/config.html","content":"Configurations\nIt's possible to supply configurations both globally (via provider) and locally (as argument to your custom hook).\nBoth configurations have the same attributes, except that the local config has one additional property autoSubmit.\nLocal Configuration\nLet's take a look at the local configuration first:\nfunction UserComponent(props: { id: number }) {\n    const [getUser] = useGetUser({\n        onInit(init) {\n            init.headers.set(\"Authorization\", \"...\");\n        }\n        onSuccess(context) {\n            console.log('success', context.data, context.status, context.responseHeaders);\n        },\n        onError(context) {\n            console.log('error', context.error, context.status, context.responseHeaders);\n        },\n        onException(context) {\n            console.log('exception', context.error);\n        },\n        autoSubmit: { id: data.id },\n    });\n    // ...\n}\n\n\nAll of the properties are optional.\nSpecify autoSubmit if you want to send the request on component mount without having to call its submit function manually.\n\nSet this to true if your prepare function does not take a data parameter\nOr set this to the data object your prepare function will receive\n\n\nSpecify callbacks for certain events instead of watching the state object in a useEffect Hook.\n\nThe hook will always use the latest version of the callbacks.\nIf the component making the request has been unmounted, the callbacks will not be called.\n\n\n\nCallback Context\nThe context parameter has different properties depending on the callback:\nexport interface CallbackContext<TVars> {\n    /** The data you used to submit the request */\n    inputData: TVars;\n}\n\nexport interface CallbackContextWithResponse<TVars> extends CallbackContext<TVars> {\n    /** The status code of the request */\n    status: number;\n    /** The response headers headers of the request */\n    responseHeaders: Headers;\n}\n\nexport interface OnSuccessContext<TVars, TData> extends CallbackContextWithResponse<TVars> {\n    /** The result of the fetch */\n    data: TData;\n}\n\nexport interface OnErrorContext<TVars, TError> extends CallbackContextWithResponse<TVars> {\n    /** The error data the server returned for the fetch */\n    error: TError;\n}\n\nexport interface OnExceptionContext<TVars> extends CallbackContext<TVars> {\n    /** The error that was thrown. */\n    error: Error;\n}\n\nGlobal Configuration\nYou can specify a global configuration by wrapping your app content in a provider:\nfunction MyApp {\n    return (\n        <FetchGlobalConfigProvider value={{\n            onInit(init) {\n                init.headers.set(\"authorization\", token);\n            },\n            onException(error) {\n                console.log(\"Exception during fetch request\", error);\n            },\n            ...\n        }}>\n            ...The app content\n        </FetchGlobalConfigProvider>\n    );\n}\n\nAs said, the only difference between local and global configurations is the autoSubmit property in local configurations.\n\nCallbacks will run both globally and locally.\n\nKeep in mind, that some of the types are different for each hook, so you'll have to manually cast the data if you need access to it.\nMost common scenarios for using the callbacks globally:\n\nAdding authorization headers to the request\nLogging and/or showing toast messages on success/error/exception events\n\n\nJust as with local callbacks: If the component making the request has been unmounted, the callbacks will not be called.\n\n\n\n","title":"Configurations","projectIndex":{"title":"use-fetch","url":"https://lusito.github.io/react-nano/use-fetch/"}},{"url":"https://lusito.github.io/react-nano/use-fetch/get.html","content":"Example: Request Data\nCreating a Custom Fetch Hook\nLet's say you have a user object you want to fetch. First you'll create a custom hook to perform the fetch:\nimport { createFetchHook, prepareGet } from \"@react-nano/use-fetch\";\n\nexport const useGetUser = createFetchHook({\n  prepare: (init: FetchRequestInit, data: { id: number }) => {\n    prepareGet(init);\n    return `api/user${data.id}`;\n  },\n  getResult: (response: Response) => response.json() as Promise<UserDTO>,\n  getError: (response: Response) => response.json() as Promise<RestValidationErrorDTO>,\n});\n\n\ncreateFetchHook creates a hook for you. See further below for more details.\nprepareGet is a helper to prepare the init object for a GET request. See further below for more details.\n\nUsing the Custom Fetch Hook\nNow you can start using your new useGetUser hook:\nimport { useGetUser } from \"./fetch/user\";\n\nfunction UserComponent(props: { id: number }) {\n    const [getUser] = useGetUser({ autoSubmit: { id: props.id });\n\n    if (getUser.failed) return <div>Error fetching user</div>;\n    if (!getUser.success) return <div>Loading..</div>;\n\n    const user = getUser.data;\n\n    return <div>{user.name}</div>;\n}\n\n\nuseGetUser can take an optional config object. See config for details.\nThe hook returns an array containing 3 items:\n\nThe first entry is the current state of the fetch request, containing the result or error data when it's done.\nsee api below for the other items\n\n\n\n","title":"Example: Request Data","projectIndex":{"title":"use-fetch","url":"https://lusito.github.io/react-nano/use-fetch/"}},{"url":"https://lusito.github.io/react-nano/use-fetch/helpers.html","content":"Helper Functions\nPreparing Init\nThe following functions will initialize the RequestInit object for specific use-cases.\nAll of them will setcredentials to \"include\" and a header Accept with value of \"application/json\"\n\nprepareGet prepares a GET request\npreparePost/Patch/Put/Delete prepares a form-data POST/PATCH/PUT/DELETE request.\npreparePostUrlEncoded prepares a form url-encoded POST request\nprepareFormDataPost prepares a POST request with a FormData object and detects if it contains files.\n\nif it contains files, it will call preparePost and set the body to the formData object.\notherwise preparePostUrlEncoded will be called and the properties of the formData will be set accordingly.\n\n\n\nYou don't need to use them. You can write your own code to initialize the RequestInit object. These are just here for convenience.\n","title":"Helper Functions","projectIndex":{"title":"use-fetch","url":"https://lusito.github.io/react-nano/use-fetch/"}},{"url":"https://lusito.github.io/react-nano/use-fetch/modify.html","content":"Example: Modify Data\nThis builds upon what you've learned in the Request Data section.\nCreating a Custom Fetch Hook\nLet's say you have a form to submit updates on a user object.\nAgain, we'll need to create a custom hook. This time it will take a FormData object in addition to the id.\nimport { setupFetch, preparePost } from \"@react-nano/use-fetch\";\n\nexport const useUpdateUser = createFetchHook({\n  prepare: (init: FetchRequestInit, data: { id: number; formData: FormData }) => {\n    prepareFormDataPost(init, data.formData);\n    init.method = \"PUT\";\n    return `api/user${data.id}`;\n  },\n  getResult: (response: Response) => response.json() as Promise<boolean>,\n  getError: (response: Response) => response.json() as Promise<RestValidationErrorDTO>,\n});\n\n\nprepareFormDataPost is a helper function, which will prepare the init object with a FormData object. See helper functions for more details.\nAdditionally, since prepareFormDataPost sets init.method to \"POST\", we override this here with a \"PUT\".\nIn this case, we expect the server to return true on success, so the result type is boolean.\nAside from that there is nothing special going on here.\n\nUsing the Custom Fetch Hook\nHere's how you might use the hook (in addition to useGetUser from the previous example):\nfunction EditUserComponent(props: { id: number }) {\n  const [getUser] = useGetUser({ autoSubmit: { id: props.id } });\n  const [updateUser, submitUpdateUser] = useUpdateUserFetch();\n\n  if (getUser.failed) return <div>Error fetching user</div>;\n  if (!getUser.success) return <div>Loading..</div>;\n\n  const user = getUser.data;\n  const validationErrors = getValidationErrors(updateUser);\n\n  return (\n    <Form\n      onSubmit={(e) => submitUpdateUser({ id: props.id, formData: new FormData(e.currentTarget) })}\n      loading={updateUser.loading}\n    >\n      <Input name=\"name\" label=\"Name\" placeholder=\"Name\" error={validationErrors.name} defaultValue={user.name} />\n      ...\n      <ErrorMessageForState state={updateUser} />\n      <button type=\"submit\">Save</button>\n    </Form>\n  );\n}\n\nThere's a lot more going on here:\n\nIn addition to getting the user, which we already did in the first example,\nWe're also using the useUpdateUserFetch hook. No autoSubmit config means we need to call it manually.\n\nThe second entry in the returned array is a submit function, which you can call to manually (re-)submit the request.\n\n\nThe server returns a validation hashmap in case of an error (implementation is up to you).\nWe're using some pseudo UI library to define our user form:\n\nonSubmit is passed on to the <form> element, so we get notified of submits.\n\nOn submit, we create a new FormData object from the <form> element.\nThe biggest advantage of this is that you don't need to connect all of your input elements to your components state.\n\n\nWhen an error happened, we try to show some information about it. See API for more information on the state values.\n\n\n\nIn case you are wondering about the implementations of ErrorMessageForState and getValidationErrors, here they are:\ninterface ErrorMessageForStateProps {\n  state: FetchState<any, RestValidationErrorDTO>;\n}\n\nexport function ErrorMessageForState({ state }: ErrorMessageForStateProps) {\n  switch (state.state) {\n    case \"error\":\n      return <div>Error {state.error.error}</div>;\n    case \"exception\":\n      return <div>Error {state.error.message}</div>;\n    default:\n      return null;\n  }\n}\n\nexport function getValidationErrors(state: FetchState<any, RestValidationErrorDTO>) {\n  return (state.state === \"error\" && state.error.validation_errors) || {};\n}\n\n","title":"Example: Modify Data","projectIndex":{"title":"use-fetch","url":"https://lusito.github.io/react-nano/use-fetch/"}},{"url":"https://lusito.github.io/react-nano/use-fetch/setup.html","content":"Setup\nThis library is shipped as es2017 modules. To use them in browsers, you'll have to transpile them using webpack or similar, which you probably already do.\nInstall via NPM\nnpm i @react-nano/use-fetch\n\n","title":"Setup","projectIndex":{"title":"use-fetch","url":"https://lusito.github.io/react-nano/use-fetch/"}}]